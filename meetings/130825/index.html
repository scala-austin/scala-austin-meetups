<!DOCTYPE html>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<script type="text/javascript" src="scripts/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="scripts/syntaxhighlighter/shBrushScala.js"></script>
<script type="text/javascript">SyntaxHighlighter.all();</script>
<link type="text/css" rel="stylesheet" href="styles/syntaxhighlighter/shCore.css"/>
<link type="text/css" rel="stylesheet" href="styles/syntaxhighlighter/shThemeDefault.css"/>

<link type="text/css" rel="stylesheet" href="styles/theme.css"/>

<script type="text/javascript" src="scripts/dzslides.js"></script>
<link type="text/css" rel="stylesheet" href="styles/dzslides.css"/>

<title>Effects without Side-effects</title>

<section>
  <h1>Effects without Side-effects</h1>
  <footer>Sukant Hajra ★ @shajra (Twitter) ★ tnks (IRC on Freenode)</footer>
</section>

<section>
  <h2>we often hear</h2>
  <blockquote>
    Scala is an OO/FP Hybrid language.
  </blockquote>
</section>

<section>
  <h2>What is “OO”?</h2>
  <ul class="incremental">
    <li> Is it modularity?
    <li> Is it inheritance?
    <li> Is it encapsulated mutable state?
  </ul>
</section>

<section>
  <h2>Scala seems to do OO well</h2>
  <h4>(even if we can't agree on what OO is).</h4>
</section>

<section>
  <h2>What is “FP”?</h2>
  <ul class="incremental">
    <li> Is “function” the same as in math?
    <li> Must we have first-class support for functions?
  </ul>
</section>

<section>
  <h2>from scala-lang.org</h2>
  <blockquote>
    Scala is also a functional language in the sense that every function is a
    value.
  </blockquote>
</section>

<section>
  <h2>From John Hughes’ “Why FP Matters”</h2>
  <ul class="incremental">
    <li> one can freely replace expressions with evaluated values
    <li> order of execution is irrelevant
  </ul>
  <div role="note">
    More generally, functional programs contain no side-effects at all. A
    function call can have no effect other than to compute its result. This
    eliminates a major source of bugs, and also makes the order of execution
    irrelevant - since no side-effect can change the value of an expression, it
    can be evaluated at any time.  This relieves the programmer of the burden
    of prescribing the flow of control.  Since expressions can be evaluated at
    any time, one can freely replace variables by their values and vice versa -
    that is, programs are “referentially transparent.”  This freedom helps make
    functional programs more tractable mathematically than their conventional
    counterparts.
  </div>
</section>

<section>
  <h2>Scala has some good support for FP</h2>
  <ul class="incremental">
    <li> first-class functions
    <li> expressions rather than statements
  </ul>
</section>

<section>
  <h2>In practice, Scala has many side-effects</h2>
  <h4>(feels more “OO/fp” than “OO/FP”).</h4>
</section>

<section>
  <h2>We can tame Scala’s side-effects with</h2>
  <ul>
    <li> discipline
    <li> library support (especially Scalaz)
  </ul>
</section>

<section>
  <h2>Let's look at code</h2>
</section>

<section>
  <h2>references</h2>
  <ul>
    <li> <a href="http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html">“Why FP Matters,” John Hughes</a>
    <li> <a href="http://typelevel.org">typelevel.org</a>
    <li> <a href="http://youtu.be/kcfIH3GYXMI">Scalaz "For the Rest of Us," Adam Rosien, BASE, Aug 2012</a>
    <li> <a href="http://youtu.be/KzoqOVD7mvE">Scala 7, Lars Hupel, NEScala 2013</a>
    <li> <a href="http://eed3si9n.com/learning-scalaz/">Learning Scalaz, Eugene Yokota</a>
  </ul>
</section>

<section>
  <h3>Next Time?</h3>
  <ul class="compressed">
    <li> style/architecture in Scala
    <li> abstracting intelligently
    <li> mastering implicits
    <li> for-yield comprehensions (monads)
    <li> error handling
    <li> dependency injection in Scala
    <li> SBT
    <li> Spark
    <li> Akka/Eventsourced/etc
  </ul>
</section>

<div id="progress-bar"></div>
